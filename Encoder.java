public class Encoder {
	static int HammingG_7_4[][] = { // macierz generujaca [7][4]
			{1,0,0,0},
			{0,1,0,0},
			{0,0,1,0},
			{0,0,0,1},
			{1,1,0,1},
			{1,1,1,0},
			{1,0,1,1}
	};
	
	static int HammingG_15_11[][] = { //macierz generujaca [15][11]
			{1,0,0,0,0,0,0,0,0,0,0},
			{0,1,0,0,0,0,0,0,0,0,0},
			{0,0,1,0,0,0,0,0,0,0,0},
			{0,0,0,1,0,0,0,0,0,0,0},
			{0,0,0,0,1,0,0,0,0,0,0},
			{0,0,0,0,0,1,0,0,0,0,0},
			{0,0,0,0,0,0,1,0,0,0,0},
			{0,0,0,0,0,0,0,1,0,0,0},
			{0,0,0,0,0,0,0,0,1,0,0},
			{0,0,0,0,0,0,0,0,0,1,0},
			{0,0,0,0,0,0,0,0,0,0,1},
			{1,1,0,1,0,0,0,1,1,1,1},
			{1,1,0,1,1,1,1,1,0,0,0},
			{1,1,1,0,0,1,1,0,0,1,1},
			{1,0,1,1,1,0,1,0,1,0,1}
	};
	
	static int HammingG_31_26[][] = { //macierz generujaca [31][26]
			{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,00},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},
			{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
			{1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1},
			{1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1},
			{1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0},
			{1,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,1,0,0,1},
			{1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,0}
	};
	
	public static int[] repetition(int[] input, int rep) { // tylko liczby nieparzyste jako liczba powtórzeń!
		int[] output = new int[rep*input.length];
		for(int i = 0; i < input.length; i++) {
			for(int j = 0; j < rep; j++) {
				output[rep*i+j] = input[i];
			}
		}
		
		return output;
	}

	public static int[] CRC(int[] input) {
		int[] output = new int[input.length];
		for(int i = 0; i < input.length; i++) {
			
		}
		
		return output;
	}

	public static int[] Hamming_7_4(int[] bits) {
		int[] output = new int[7 * (bits.length/4)];
		// Kod cykliczny Hamminga (7,4)
		
		for(int i = 0; i < bits.length; i+=4) {
			//dzielenie na pakiety 4-bitowe z 3-bit nadmiarem
			for(int j = 0; j < 4; j++) { // 4-bitowy wektor p
				for(int k = 0; k < 7; k++) {
					output[7*i/4 + k] += HammingG_7_4[k][j]*bits[i + j]; // mnozenie macierzowe G*p
				}
			}
		}
		for (int i = 0; i < output.length; i++) {
			output[i] = output[i]%2;
		}
		
		return output;
	}
	
	public static int[] Hamming_15_11(int[] bits) {
		int[] output = new int[15 * (bits.length/11)];
		// Kod cykliczny Hamminga (15,11)
		
		for(int i = 0; i < bits.length; i+=11) {
			//dzielenie na pakiety 11-bitowe z 4-bit nadmiarem
			for(int j = 0; j < 11; j++) { // 4-bitowy wektor p
				for(int k = 0; k < 15; k++) {
					output[15*i/11 + k] += HammingG_15_11[k][j]*bits[i + j]; // mnozenie macierzowe G*p
				}
			}
		}
		for (int i = 0; i < output.length; i++) {
			output[i] = output[i]%2;
		}
		
		return output;
	}
	
	public static int[] Hamming_31_26(int[] bits) {
		int[] output = new int[31 * (bits.length/26)];
		// Kod cykliczny Hamminga (31,26)
		
		for(int i = 0; i < bits.length; i+=26) {
			//dzielenie na pakiety 26-bitowe z 5-bit nadmiarem
			for(int j = 0; j < 26; j++) { // 4-bitowy wektor p
				for(int k = 0; k < 31; k++) {
					output[31*i/26 + k] += HammingG_31_26[k][j]*bits[i + j]; // mnozenie macierzowe G*p
				}
			}
		}
		for (int i = 0; i < output.length; i++) {
			output[i] = output[i]%2;
		}
		
		return output;
	}

}
